# 파사드 패턴 (Facade Pattern)
#### Facade : (건물의) 정면, (실제와는 다른) 표면, 허울
#### 프로그래밍 언어에서 관심사를 분리하는 패턴이다.

---
## 협업을 위한 분리 작업
#### 1. 복잡한 구조의 개발작업
> ###### 대형 시스템을 효율적으로 개발하려면 기능을 모듈별로 분리하고 분리된 모듈을 공동으로 개발하는 것이 좋다.

#### 2. 분리된 모듈의 결합
> ###### 객체 지향 방식에서 하나의 모듈을 작게 분리하고 클래스로 캡슐화하며, 작게 분리된 모듈은 다른 기능 구현에도 재사용 된다.
> ###### 이 과정에서 수많은 클래스 객체가 생성되고 객체는 복잡한 구조의 관계를 가진다.
> ###### 코드를 결합한 후에도 리팩터링이나 변화가 있을 때를 대비하여 지속적으로 코드를 유지 보수 해야한다.

#### 3. 느슨한 결합
> ###### 파사드 패턴은 강력한 결합 구조를 해결하기 위해 코드의 의존성을 줄이고 느슨한 결합으로 구조를 변경합니다.
> ###### 파사드 패턴은 메인시스템과 서브시스템 중간에 위치해, 새로운 인터페이스 계층을 추가하여 시스템 간 의존성을 해결한다. (즉, 서브시스템 밖에 Facade(외벽)을 세우는 것이다.)
> ###### 파사드로 인해 새로운 계층이 하나 더 추가 되면 관리할 클래스가 하나 더 생성된다는 단점이 있지만, 강력한 객체의 결합도를 낮추고 유연한 구조를 가질 수 있다는 장점이 있다.

---
## 파사드 패턴을 응용한 API
#### 1. 구조
> ###### 파사드는 GoF에서 설명하는 구조 패턴 중 하나며 파사드 패턴은 싱글턴 추상 팩토리(Singleton Abstract Factory)라고 불리기도 한다.
> ###### 파사드는 어떤 기능에 접글할 수 있는 단일화된 추상 클래스를 만든다.
> ###### 예를 들어, 은행에 가면 창구가 있다. 은행원에게 원하는 업무를 요청하면 은행 내부 시스템을 몰라도 은행 업무를 처리 할수있다.
> ###### 은행원은 고객과 은행 전산 시슽메을 이어주느 인터페이스 역할인 것이다. 이처럼 파사드는 은행원의 역할과 같다.

#### 2. 인터페이스
> ###### 파사드는 서브 시스템을 호출, 결합할 수 있는 인터페이스를 제공한다.
> ###### 인터페이스는 한 개 일수도 있고 여러 개일 수도 있다. 또 이를 함수형태로 제공하기도 한다.
> ###### 이를 이용하면 클라이언트는 세부적인 기능을 일일이 알필요가없다. (마치 은행 고객처럼)

#### 3. 최상의 인터페이스
> ###### 파사드는 통합 인터페이스이다. 복잡하게 얽힌 서브 시스템의 로직을 쉽게 사용할 수 있도록 상위 레벨 인터페이스로 재정의한다.
> ###### 상위 레벨의 인터페이스는 캡슐화하여 하위 시스템에 접근한다.

---
## 파사드를 이용한 단순화
#### 1. 단순화
> ###### 파사드 패턴은 서브 기능을 쉽게 사용할 수 있도록 단순화 한다.
> ###### 즉 파사드로 제공되는 인터페이스만 알고 있으면 사용 가능하다.

#### 2. 캡슐화 배제
> ###### 파사드 패턴을 구현하기 위해 서브 시스템의 캡슐화 작업을 별도로 진행하지 않는다. 파사드는 단순한 인터페이스다.

#### 3. 복잡성 해결
> ###### 파사드는 서브 시스템을 구조화하여 복잡성을 해결하는 데 도움을 준다.

#### 4. 의존성 감소
> ###### 서브 시스템의 객체가 다른 객체에 의존성을 요구하는 경우가 있다.
> ###### 이 경우, 특정한 서브 시스템의 계층에 접근하기 위해 의존하는 객체를 미리 생성하는 과정이 필요하다.
> ###### 파사드 패턴을 응용할 경우 이러한 객체의 의존 관계를 사전에 해결할 수 있다.
> ###### 즉 실체 객체에 접근하기 전에 필요한 작업을 먼저 실행할 수 있도록 도와준다.

---
## 최소 지식 원칙(Principle of Least Knowledge)
> ###### 파사드 패턴은 객체지향의 최소 지식 원칙이 적용 되는 좋은 예시이다.
> ###### 최소 지식 원칙은 데메테르의 법칙 이라고도 한다.
#### 1. 최소 지식
> ###### 복잡하게 얽혀 있는 서브 시스템의 어떤 부분을 수정할 경우 관련된 다른 부분도 같이 수정해야 하는 경우가 있다.
> ###### 하나를 수정할 때 많은 연관 정보(지식)를 알고 있어야 한다.
> ###### 이처럼 어떤 작업을 할 때 많은 지식이 있어야 한다면 코드를 쉽게 수정하기 어렵다.
> ###### 따라서, 최소 지식만 적용해 객체의 상호 작용을 설정하면 유지 보수가 용이해진다.
#### 2. 잘못된 예
> ###### 객체의 메서드를 호출할 떄는 단ㅅ순화해서 접근하거나 호출하는 것이 좋다.
> ###### 불필요한 객체의 생성 루틴과 재호출을 코드에 삽입해 코드의 가독성과 복잡성을 증가시키지 않도록 해야 한다.
> ###### 다음은 온도계 예시이다.
```java
//서브 시스템
public class Thermometer {
    private float temp;

    public float getTemperature() {
        return temp;
    }
}

//파사드
public class Temperature {
    public Thermometer station;

    public Temperature(Thermometer station) {
        this.station = station;
    }

    public float getTemp(){
        // 인스턴스 저장 (불필요한 호출)
        Thermometer thermometer = this.getThermometer();
        //  인스턴스를 통해 메서드 실행
        return thermometer.getTemperature();
    }
    // 불필요함
    private Thermometer getThermometer() {
        return station;
    }
}
```
> ###### ```Temperature```클래스의  ```getTemp()```메서드의 ```thermometer```에 객체를 반환 받고 있다. (메모리 낭비)
> ###### 이러면 ```Temperature```를 수정할떄 ```thermometer```변수에 담긴 객체 정보를 이해해야 한다.
> ###### 즉 코드의 복잡성이 증가하는 것이다.
> ###### 위의 코드는 다음과 같이 수정해야 한다.
```java
    ...
    public float getTemp(){
        return this.station.getTemperature();
    } 
    ...
```
#### 3. 최소 지식 객체
> ###### 최소 지식 객체를 만들기 위해서는 다음 4가지 규칙을 지키면 된다.
> ###### 1. 자기 자신만의 객체 사용
> ###### 2. 메서드에 전달된 매개 변수 사용
> ###### 3. 메서드에서 생성된 객체 사용
> ###### 4. 객체에 속하는 메서드 사용

---
## 기본 실습
> ###### 파사드 패턴은 다른 디자인 패턴과 달리 특정한 구조를 갖지 않으며, 파사드 패턴을 생성하는 방법은 매우 다양하다.
#### 1. 서브 시스템
> ###### 파사드는 복잡한 구조의 서브 시스템을 간단하게 호출할 수 있도록 하는 인터페이스 모음이다.
> ###### 예제에서 가상의 서브클래스 package1,2,3을 생성한다. 이 객체들은 어떤 라이브러리의 집단 이거나 API일 것이다.
```java
public class Package1 {
    public Package1() {
        System.out.println("Package1 생성");
    }
    public void process(){
        System.out.println("패키지1 작업을 진행합니다!");
    }
}
public class Package2 {
    public Package2() {
        System.out.println("Package2 생성");
    }
    public void process(){
        System.out.println("패키지2 작업을 진행합니다!");
    }
}
public class Package3 {
    public Package3() {
        System.out.println("Package3 생성");
    }
    public void process(){
        System.out.println("패키지3 작업을 진행합니다!");
    }
}
```
> ###### 파사드의 서브 시스템은 한 개의 클래스만으로 구성이 가능하며 여러 개의 클래스도 가능하다.
> ###### 파사드가 제공하는 서브 시스템은 복잡한 구조를 갖고 있다고 상상하자.

#### 2. 직접 접근
```java
    ...
    public static void main(String[] args) {
        Package1 p1 = new Package1();
        Package2 p2 = new Package2();
        Package3 p3 = new Package3();

        p1.process();
        p2.process();
        p3.process();
    }
    ...
```
#### 실행 결과
```aidl
Package1 생성
Package2 생성
Package3 생성
패키지1 작업을 진행합니다!
패키지2 작업을 진행합니다!
패키지3 작업을 진행합니다!
```
> ###### 위와 같이 복잡한 서브 시스템을 직접 접근해 사용하려면 서브 시스템의 내부 구조를 모두 알아야 한다.
> ###### 하지만, 서브 시스템을 개발, 유지 보수하는 개발자가 아니라면 상세 기능을 파악하기 힘들다.

#### 3. 파사드 생성
```java
public class Facade {
    private Package1 package1;
    private Package2 package2;
    private Package3 package3;

    public Facade() {
        this.package1 = new Package1();
        this.package2 = new Package2();
        this.package3 = new Package3();
    }
    
    // 패키지 동작 1,2,3을 한번에 수행 해야 되는
    // 복잡한 동작을 파사드 메서드로 생성한다.
    public void processAll(){
        this.package1.process();
        this.package2.process();
        this.package3.process();
    }
}
```
> ###### 위와 같이 파사드 패턴은 복잡한 동작이나 패키지를 쉽게 처리할 수 있도록 외부 메서드를 제공한다.
> ###### 이렇게 제공되는 메서드를 호출 하면서 복잡한 기능을 한번에 처리할 수 있다.
```java
    ...
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.processAll();
    }
    ...
```
#### 실행 결과
```aidl
Package1 생성
Package2 생성
Package3 생성
패키지1 작업을 진행합니다!
패키지2 작업을 진행합니다!
패키지3 작업을 진행합니다!
```
> ###### 위와 같이 파사드를 적용하면 클라이언트는 복잡한 패키지1,2,3의 process를 몰라도 Facade의 processAll()만 알면 간단히 실행 할수 있다.

---
## 파사드 패턴의 효과
#### 1. 서브 시스템 보호
> ###### 서브 시스템의 구성 용소를 직접 호출하지 않으므로 잘못된 사용을 방지할 수 있다.
> ###### 파사드는 외부 사용과 내부 구조를 구분한다. 이를 응용하면 추후 서브 시스템을 업그레이드 하는 경우에도 자유롭다.

#### 2. 확장성
> ###### 서비스를 유지하는 동안 새로운 요청과 생각하지 못했던 오류가 발견되곤한다
> ###### 따라서 안정적인 서비스를 유지하기 위해서는 지속적인 코드 변경이 필요하다.
> ###### 하지만 서비스 중인 코드를 변경하는 것은 쉽지 않다.
> ###### 변화되는 코드를 파사드 형태로 제공하면 보다 쉽게 변경 및 확장할 수 있다.
> ###### 상위 시스템에는 파사드를 이용하므로 서브 시스템이 변경 돼도 큰 변화를 느낄 수 없다.

#### 3. 결합도 감소
> ###### 서브 시스템이 복잡하고 종속성이 강할 떄는 파사드 패턴을 이용한다.
> ###### 직접적으로 서브 시스템의 객체에 접근하지 않고 인터페이스와 유사한 역할을 하는 파사드를 이용하여 서브 시스템에 접근할 수 있다.
> ###### 파사드는 복잡한 종속적 결합도를 낮춰주고 독립적인 코드를 유지할 수 있도록 도와준다.

#### 4. 계층화
> ###### 복잡한 서브 시스템은 계층화 구조로 되어 있는 경우가 많다.
> ###### 복합 객체 또는 복합체와 같은 패턴 (Composite Pattern)을 활용하면 객체는 계층화 되면서 복잡한 구조를 갖는다.
> ###### 파사드는 게층 단계별로 접근하여 행위를 호출할 수 있다. (파사드 개수에는 제한이 없다.)

#### 5. 이식성
> ###### 파사드 패턴은 코드의 결합도를 약하게 하는 효과를 발생시킨다.
> ###### 결합도가 약해지면 코드를 쉽게 재사용할 수 있다. 따라서 이식성이 향상된다.

#### 6. 공개 인터페이스
> ###### 파사드를 사용하면 필요한 행위만 노출하고 그 외의 코드를 비공개로 숨길 수 있다.
> ###### 파사드는 인터페이스를 제공함과 동시에 서브 시스템의 기능을 캡슐화 한다.
> ###### 인터페이스를 활용한 캡슐화를 통해 공개할 부분과 공개하지 않을 부분을 결정한다.

---
## 관련 패턴
> ###### 추상 팩토리, 어댑터, 중재자(Mediator), 싱글톤

